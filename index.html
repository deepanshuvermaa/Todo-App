<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LifeTracker - Your Personal Productivity Assistant</title>
    <meta name="description" content="Personal productivity app with Google Sheets integration, voice commands, and mobile-first design">
    <meta name="theme-color" content="#28a745">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="LifeTracker">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìù</text></svg>">
</head>
<body>
    <!-- Loading overlay -->
    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading LifeTracker...</div>
        </div>
    </div>

    <!-- Header -->
    <header class="app-header">
        <h1>üìù LifeTracker</h1>
        <p id="current-date"></p>
        <button id="dark-mode-toggle" class="dark-mode-toggle">üåô</button>
    </header>

    <!-- Desktop Navigation -->
    <nav class="top-nav">
        <div class="nav-section">
            <button class="nav-link active" data-view="today">TODAY</button>
            <button class="nav-link" data-view="history">HISTORY</button>
            <button class="nav-link" data-view="settings">SETTINGS</button>
            <button class="nav-link" data-view="about">ABOUT</button>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Today View -->
        <section id="today-view" class="view active">
            <!-- Mobile Card Layout -->
            <div class="mobile-cards-container">
                <div class="cards-viewport">
                    <!-- Quick Input Card -->
                    <div class="home-card input-card">
                        <div class="card-header">
                            <h3>‚úçÔ∏è Quick Add</h3>
                            <span class="card-subtitle">Add a new task</span>
                        </div>
                        <div class="task-input-section">
                            <label for="task-input" class="sr-only">Enter a new task</label>
                            <input type="text" id="task-input" placeholder="What do you want to accomplish today?" maxlength="200" aria-label="Enter a new task">
                            <button id="add-task-btn" aria-label="Add new task">
                                Add Task
                                <span class="sr-only">Press Enter or click to add task</span>
                            </button>
                        </div>
                    </div>

                    <!-- Today's Tasks Card -->
                    <div class="home-card tasks-card">
                        <div class="card-header">
                            <h3>üìå Today's Tasks</h3>
                            <span class="card-subtitle" id="pending-count">0 pending</span>
                        </div>
                        <div class="card-content">
                            <ul id="pending-tasks" class="task-list" role="list" aria-label="Pending tasks"></ul>
                            <div class="empty-state" id="empty-pending" role="status" aria-live="polite">
                                <span aria-hidden="true">üéØ</span>
                                <p>No tasks yet. Add one above!</p>
                            </div>
                        </div>
                    </div>

                    <!-- Completed Tasks Card -->
                    <div class="home-card completed-card">
                        <div class="card-header">
                            <h3>‚úÖ Completed</h3>
                            <span class="card-subtitle" id="completed-count">0 done</span>
                        </div>
                        <div class="card-content">
                            <ul id="completed-tasks" class="task-list" role="list" aria-label="Completed tasks"></ul>
                            <div class="empty-state" id="empty-completed" role="status" aria-live="polite">
                                <span aria-hidden="true">üèÜ</span>
                                <p>Completed tasks appear here</p>
                            </div>
                        </div>
                    </div>

                    <!-- Progress Card -->
                    <div class="home-card progress-card">
                        <div class="card-header">
                            <h3>üìä Progress</h3>
                            <span class="card-subtitle">Today's performance</span>
                        </div>
                        <div class="stats-section">
                            <div class="stat-grid">
                                <div class="stat-item">
                                    <span class="stat-number" id="total-tasks">0</span>
                                    <span class="stat-label">Total</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-number" id="completion-percentage">0</span>
                                    <span class="stat-label">% Done</span>
                                </div>
                            </div>
                            <div class="progress-bar-container">
                                <div class="progress-bar">
                                    <div class="progress-fill" id="completion-bar"></div>
                                </div>
                                <div class="progress-text">
                                    <span>Completion: <span id="completion-percentage-text">0%</span></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quick Actions Card -->
                    <div class="home-card actions-card">
                        <div class="card-header">
                            <h3>‚ö° Quick Actions</h3>
                            <span class="card-subtitle">Common tasks</span>
                        </div>
                        <div class="quick-actions">
                            <button class="action-btn" data-action="clear-completed">
                                <span class="action-icon">üóëÔ∏è</span>
                                <span class="action-text">Clear Done</span>
                            </button>
                            <button class="action-btn" data-action="sync-data">
                                <span class="action-icon">üîÑ</span>
                                <span class="action-text">Sync Sheet</span>
                            </button>
                            <button class="action-btn" data-action="voice-add">
                                <span class="action-icon">üé§</span>
                                <span class="action-text">Voice Add</span>
                            </button>
                            <button class="action-btn" data-action="export-day">
                                <span class="action-icon">üì§</span>
                                <span class="action-text">Export Day</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Card Navigation Dots -->
                <div class="card-dots">
                    <span class="dot active" data-card="0"></span>
                    <span class="dot" data-card="1"></span>
                    <span class="dot" data-card="2"></span>
                    <span class="dot" data-card="3"></span>
                    <span class="dot" data-card="4"></span>
                </div>
            </div>

            <!-- Desktop Layout (unchanged) -->
            <div class="desktop-layout">
                <div class="task-input-section">
                    <input type="text" id="task-input-desktop" placeholder="What do you want to accomplish today?" maxlength="200">
                    <button id="add-task-btn-desktop">Add Task</button>
                </div>

                <div class="task-lists">
                    <div class="pending-section">
                        <h3>üìå Today's Tasks</h3>
                        <ul id="pending-tasks-desktop"></ul>
                    </div>

                    <div class="completed-section">
                        <h3>‚úÖ Completed</h3>
                        <ul id="completed-tasks-desktop"></ul>
                    </div>
                </div>

                <div class="stats-section">
                    <div class="stat">
                        <span class="stat-label">Total Tasks:</span>
                        <span id="total-tasks-desktop">0</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="completion-bar-desktop"></div>
                    </div>
                    <div class="percentage-display">
                        <span>Completion: <span id="completion-percentage-desktop">0</span>%</span>
                        <span>Procrastination: <span id="procrastination-percentage-desktop">0</span>%</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- History View -->
        <section id="history-view" class="view">
            <div class="history-controls">
                <button id="load-history-btn">Load History</button>
                <button id="save-sheet-btn">Save to Sheet</button>
                <button id="view-sheet-btn">View Sheet</button>
            </div>
            <div id="history-content"></div>
        </section>

        <!-- Settings View -->
        <section id="settings-view" class="view">
            <div class="settings-content">
                <h3>Settings</h3>
                <div class="setting-item">
                    <label for="sheet-url">Google Sheet URL:</label>
                    <input type="url" id="sheet-url" placeholder="https://docs.google.com/spreadsheets/d/...">
                </div>
                <div class="setting-item">
                    <button id="connect-sheet-btn">Connect Sheet</button>
                </div>
            </div>
        </section>

        <!-- About View -->
        <section id="about-view" class="view">
            <div class="about-content">
                <h3>About LifeTracker</h3>
                <p>Your personal productivity assistant with Google Sheets integration.</p>
            </div>
        </section>

        <!-- Sync Status -->
        <div id="sync-status-indicator" class="sync-indicator"></div>

        <!-- Mobile Notes Toggle Button -->
        <button id="mobile-notes-toggle" class="mobile-notes-toggle">üìù</button>
        
        <!-- Notes Sidebar -->
        <div id="notes-sidebar" class="notes-sidebar">
            <button id="close-notes-btn" class="close-notes-btn">√ó</button>
            <h3>Quick Notes</h3>
            <textarea id="notes-textarea" placeholder="Jot down your thoughts..."></textarea>
            <button id="save-notes-btn">Save Notes</button>
        </div>
    </main>

    <!-- Mobile Bottom Navigation Dock -->
    <nav class="bottom-dock" role="navigation" aria-label="Main navigation">
        <button class="dock-item active" data-view="today" aria-label="Today's tasks" aria-current="page">
            <span class="dock-icon" aria-hidden="true">üìù</span>
            <span class="dock-label">Today</span>
        </button>
        <button class="dock-item" data-view="history" aria-label="View history">
            <span class="dock-icon" aria-hidden="true">üìä</span>
            <span class="dock-label">History</span>
        </button>
        <button class="dock-item" data-view="settings" aria-label="Open settings">
            <span class="dock-icon" aria-hidden="true">‚öôÔ∏è</span>
            <span class="dock-label">Settings</span>
        </button>
        <button class="dock-item" data-view="about" aria-label="About this app">
            <span class="dock-icon" aria-hidden="true">‚ÑπÔ∏è</span>
            <span class="dock-label">About</span>
        </button>
        <button class="dock-item" id="voice-dock-btn" aria-label="Voice commands">
            <span class="dock-icon" aria-hidden="true">üé§</span>
            <span class="dock-label">Voice</span>
        </button>
    </nav>

    <!-- Floating Voice Button (fallback for desktop) -->
    <div class="floating-voice-btn">
        <button class="voice-fab" id="voice-button" title="Click and speak">
            üé§
        </button>
    </div>

    <!-- Scripts -->
    <script src="config.js"></script>
    <script src="google-auth.js"></script>
    <script src="voice-commands.js"></script>
    <script src="app.js"></script>

    <script>
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Fix mobile compatibility - Bridge mobile and desktop elements
            function createCompatibilityLayer() {
                // For mobile: sync desktop elements with mobile elements
                const taskInputMobile = document.getElementById('task-input');
                const addTaskBtnMobile = document.getElementById('add-task-btn');
                const taskInputDesktop = document.getElementById('task-input-desktop');
                const addTaskBtnDesktop = document.getElementById('add-task-btn-desktop');
                
                if (window.innerWidth <= 768) {
                    // Mobile: ensure mobile elements work with existing app
                    if (taskInputMobile && addTaskBtnMobile) {
                        // App.js looks for these exact IDs - mobile already has them, good!
                        console.log('Mobile elements ready');
                    }
                    
                    // Hide desktop elements on mobile
                    const desktopLayout = document.querySelector('.desktop-layout');
                    if (desktopLayout) desktopLayout.style.display = 'none';
                    
                } else {
                    // Desktop: ensure desktop elements work
                    if (taskInputDesktop && addTaskBtnDesktop) {
                        // Update IDs so app.js can find them
                        taskInputDesktop.id = 'task-input';
                        addTaskBtnDesktop.id = 'add-task-btn';
                        
                        // Also update task lists
                        const pendingDesktop = document.getElementById('pending-tasks-desktop');
                        const completedDesktop = document.getElementById('completed-tasks-desktop');
                        const totalTasksDesktop = document.getElementById('total-tasks-desktop');
                        const completionPercentDesktop = document.getElementById('completion-percentage-desktop');
                        const completionBarDesktop = document.getElementById('completion-bar-desktop');
                        
                        if (pendingDesktop) pendingDesktop.id = 'pending-tasks';
                        if (completedDesktop) completedDesktop.id = 'completed-tasks';
                        if (totalTasksDesktop) totalTasksDesktop.id = 'total-tasks';
                        if (completionPercentDesktop) completionPercentDesktop.id = 'completion-percentage';
                        if (completionBarDesktop) completionBarDesktop.id = 'completion-bar';
                    }
                    
                    // Hide mobile elements on desktop
                    const mobileLayout = document.querySelector('.mobile-cards-container');
                    if (mobileLayout) mobileLayout.style.display = 'none';
                }
                
                // Ensure required elements exist for app.js
                const requiredElements = ['current-date', 'sync-status-indicator'];
                requiredElements.forEach(id => {
                    if (!document.getElementById(id)) {
                        const elem = document.createElement('div');
                        elem.id = id;
                        if (id === 'sync-status-indicator') {
                            elem.className = 'sync-indicator';
                        }
                        elem.style.display = 'none';
                        document.body.appendChild(elem);
                    }
                });
            }
            
            // Create compatibility layer first
            createCompatibilityLayer();
            
            // Initialize app
            const app = new TodoApp();
            
            // Override app methods for mobile compatibility
            if (window.innerWidth <= 768) {
                // Override renderTasks to work with mobile layout
                const originalRenderTasks = app.renderTasks.bind(app);
                app.renderTasks = function() {
                    // Call original method
                    originalRenderTasks();
                    
                    // Update mobile-specific counters and empty states
                    updateMobileCounters();
                    updateMobileEmptyStates();
                };
                
                // Override updateMetrics for mobile
                const originalUpdateMetrics = app.updateMetrics.bind(app);
                app.updateMetrics = function() {
                    // Call original method
                    originalUpdateMetrics();
                    
                    // Update mobile progress indicators
                    updateMobileMetrics();
                };
                
                function updateMobileCounters() {
                    const pendingTasks = document.querySelectorAll('#pending-tasks li').length;
                    const completedTasks = document.querySelectorAll('#completed-tasks li').length;
                    
                    const pendingCount = document.getElementById('pending-count');
                    const completedCount = document.getElementById('completed-count');
                    
                    if (pendingCount) {
                        pendingCount.textContent = `${pendingTasks} pending`;
                        pendingCount.classList.add('updated');
                        setTimeout(() => pendingCount.classList.remove('updated'), 600);
                    }
                    
                    if (completedCount) {
                        completedCount.textContent = `${completedTasks} done`;
                        if (completedTasks > 0) {
                            completedCount.style.color = '#28a745';
                            completedCount.style.fontWeight = '600';
                        }
                    }
                }
                
                function updateMobileEmptyStates() {
                    const pendingList = document.getElementById('pending-tasks');
                    const completedList = document.getElementById('completed-tasks');
                    const emptyPending = document.getElementById('empty-pending');
                    const emptyCompleted = document.getElementById('empty-completed');
                    
                    if (pendingList && emptyPending) {
                        emptyPending.style.display = pendingList.children.length === 0 ? 'block' : 'none';
                    }
                    
                    if (completedList && emptyCompleted) {
                        emptyCompleted.style.display = completedList.children.length === 0 ? 'block' : 'none';
                    }
                }
                
                function updateMobileMetrics() {
                    const pendingTasks = document.querySelectorAll('#pending-tasks li').length;
                    const completedTasks = document.querySelectorAll('#completed-tasks li').length;
                    const totalTasks = pendingTasks + completedTasks;
                    const progressPercent = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
                    
                    // Update mobile progress elements
                    const totalTasksElement = document.getElementById('total-tasks');
                    const completionPercentElement = document.getElementById('completion-percentage');
                    const completionPercentTextElement = document.getElementById('completion-percentage-text');
                    const completionBarElement = document.getElementById('completion-bar');
                    
                    if (totalTasksElement) totalTasksElement.textContent = totalTasks;
                    if (completionPercentElement) completionPercentElement.textContent = progressPercent;
                    if (completionPercentTextElement) completionPercentTextElement.textContent = progressPercent + '%';
                    if (completionBarElement) completionBarElement.style.width = progressPercent + '%';
                }
                
                // Enhance task items for mobile gestures
                function enhanceTaskItems() {
                    const taskItems = document.querySelectorAll('.task-list li');
                    taskItems.forEach((item, index) => {
                        // Ensure proper mobile structure
                        if (!item.dataset.enhanced) {
                            // Add data attributes for swipe gestures
                            item.dataset.taskId = item.dataset.taskId || index;
                            item.dataset.enhanced = 'true';
                            
                            // Ensure checkbox is properly structured
                            const checkbox = item.querySelector('input[type="checkbox"]');
                            if (checkbox && !item.querySelector('.task-content')) {
                                const content = item.innerHTML.replace(checkbox.outerHTML, '');
                                item.innerHTML = `
                                    ${checkbox.outerHTML}
                                    <div class="task-content">${content.trim()}</div>
                                    <div class="task-time">${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                                `;
                            }
                        }
                    });
                }
                
                // Override the original method to enhance tasks after rendering
                const originalCreateTaskElement = app.createTaskElement?.bind(app);
                if (originalCreateTaskElement) {
                    app.createTaskElement = function(task) {
                        const element = originalCreateTaskElement(task);
                        // Mobile-specific enhancements would go here
                        return element;
                    };
                }
                
                // Monitor task list changes and enhance new items
                const observer = new MutationObserver(() => {
                    enhanceTaskItems();
                });
                
                ['#pending-tasks', '#completed-tasks'].forEach(selector => {
                    const element = document.querySelector(selector);
                    if (element) {
                        observer.observe(element, { childList: true });
                    }
                });
                
                // Initial enhancement
                setTimeout(enhanceTaskItems, 1000);
                
                // Fix mobile task input
                const mobileTaskInput = document.getElementById('task-input');
                const mobileAddBtn = document.getElementById('add-task-btn');
                
                if (mobileTaskInput && mobileAddBtn) {
                    // Ensure Enter key works on mobile input
                    mobileTaskInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            if (app && typeof app.addTask === 'function') {
                                app.addTask();
                            } else {
                                // Fallback manual task addition
                                const taskText = this.value.trim();
                                if (taskText) {
                                    const newTask = {
                                        id: Date.now().toString(),
                                        text: taskText,
                                        completed: false,
                                        date: app.currentDate.toISOString().split('T')[0],
                                        createdAt: new Date().toISOString()
                                    };
                                    app.tasks.push(newTask);
                                    app.saveTasks();
                                    app.renderTasks();
                                    app.updateMetrics();
                                    this.value = '';
                                    showSwipeFeedback('Task added!', 'success');
                                }
                            }
                        }
                    });
                    
                    // Ensure button click works
                    mobileAddBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (app && typeof app.addTask === 'function') {
                            app.addTask();
                        }
                    });
                }
            }
            
            // Initialize voice commands
            if (typeof VoiceCommands !== 'undefined') {
                const voiceCommands = new VoiceCommands(app);
            }

            // Mobile card swipe functionality
            let currentCard = 0;
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            
            const cardsViewport = document.querySelector('.cards-viewport');
            const cards = document.querySelectorAll('.home-card');
            const dots = document.querySelectorAll('.dot');
            
            if (cardsViewport && window.innerWidth <= 768) {
                // Touch events for mobile swipe
                cardsViewport.addEventListener('touchstart', handleTouchStart, { passive: true });
                cardsViewport.addEventListener('touchmove', handleTouchMove, { passive: false });
                cardsViewport.addEventListener('touchend', handleTouchEnd, { passive: true });
                
                // Mouse events for testing on desktop
                cardsViewport.addEventListener('mousedown', handleMouseDown);
                cardsViewport.addEventListener('mousemove', handleMouseMove);
                cardsViewport.addEventListener('mouseup', handleMouseUp);
                cardsViewport.addEventListener('mouseleave', handleMouseUp);
            }

            function handleTouchStart(e) {
                startX = e.touches[0].clientX;
                isDragging = true;
            }

            function handleTouchMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                currentX = e.touches[0].clientX;
                const diffX = currentX - startX;
                const translateX = -currentCard * 100 + (diffX / window.innerWidth) * 100;
                cardsViewport.style.transform = `translateX(${translateX}%)`;
            }

            function handleTouchEnd(e) {
                if (!isDragging) return;
                isDragging = false;
                
                const diffX = currentX - startX;
                const threshold = window.innerWidth * 0.2; // 20% of screen width
                
                if (Math.abs(diffX) > threshold) {
                    if (diffX > 0 && currentCard > 0) {
                        currentCard--;
                    } else if (diffX < 0 && currentCard < cards.length - 1) {
                        currentCard++;
                    }
                }
                
                updateCardPosition();
                updateDots();
            }

            function handleMouseDown(e) {
                startX = e.clientX;
                isDragging = true;
                cardsViewport.style.cursor = 'grabbing';
            }

            function handleMouseMove(e) {
                if (!isDragging) return;
                currentX = e.clientX;
                const diffX = currentX - startX;
                const translateX = -currentCard * 100 + (diffX / window.innerWidth) * 100;
                cardsViewport.style.transform = `translateX(${translateX}%)`;
            }

            function handleMouseUp(e) {
                if (!isDragging) return;
                isDragging = false;
                cardsViewport.style.cursor = 'grab';
                
                const diffX = currentX - startX;
                const threshold = window.innerWidth * 0.2;
                
                if (Math.abs(diffX) > threshold) {
                    if (diffX > 0 && currentCard > 0) {
                        currentCard--;
                    } else if (diffX < 0 && currentCard < cards.length - 1) {
                        currentCard++;
                    }
                }
                
                updateCardPosition();
                updateDots();
            }

            function updateCardPosition() {
                cardsViewport.style.transform = `translateX(-${currentCard * 100}%)`;
                cardsViewport.style.transition = 'transform 0.3s ease';
                
                setTimeout(() => {
                    cardsViewport.style.transition = '';
                }, 300);
            }

            function updateDots() {
                dots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === currentCard);
                });
            }

            // Dot navigation
            dots.forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    currentCard = index;
                    updateCardPosition();
                    updateDots();
                });
            });

            // Navigation handling
            function handleNavigation() {
                const navButtons = document.querySelectorAll('.nav-link, .dock-item[data-view]');
                navButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        const view = this.dataset.view;
                        if (view) {
                            // Update active states
                            navButtons.forEach(btn => {
                                btn.classList.remove('active');
                                btn.removeAttribute('aria-current');
                            });
                            
                            navButtons.forEach(btn => {
                                if (btn.dataset.view === view) {
                                    btn.classList.add('active');
                                    btn.setAttribute('aria-current', 'page');
                                }
                            });
                            
                            // Switch views
                            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                            const targetView = document.getElementById(view + '-view');
                            if (targetView) {
                                targetView.classList.add('active');
                                
                                // If switching to today view on mobile, reset card position
                                if (view === 'today' && window.innerWidth <= 768) {
                                    currentCard = 0;
                                    updateCardPosition();
                                    updateDots();
                                }
                                
                                // Update app's current view if it has a switchTab method
                                if (app && typeof app.switchTab === 'function') {
                                    app.switchTab({ target: { dataset: { tab: view } } });
                                }
                            }
                        }
                    });
                });
            }

            handleNavigation();

            // Handle voice dock button
            const voiceDockBtn = document.getElementById('voice-dock-btn');
            const voiceButton = document.getElementById('voice-button');
            if (voiceDockBtn && voiceButton) {
                voiceDockBtn.addEventListener('click', function() {
                    voiceButton.click();
                });
            }

            // Handle mobile notes toggle
            const mobileNotesToggle = document.getElementById('mobile-notes-toggle');
            const notesSidebar = document.getElementById('notes-sidebar');
            const closeNotesBtn = document.getElementById('close-notes-btn');

            if (mobileNotesToggle && notesSidebar) {
                mobileNotesToggle.addEventListener('click', function() {
                    notesSidebar.classList.add('mobile-open');
                });
            }

            if (closeNotesBtn && notesSidebar) {
                closeNotesBtn.addEventListener('click', function() {
                    notesSidebar.classList.remove('mobile-open');
                });
            }

            // Quick Actions handlers
            const actionButtons = document.querySelectorAll('.action-btn');
            actionButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    const action = this.dataset.action;
                    handleQuickAction(action);
                });
            });

            function handleQuickAction(action) {
                switch(action) {
                    case 'clear-completed':
                        if (app) {
                            // Clear completed tasks - remove all completed tasks
                            const completedList = document.getElementById('completed-tasks');
                            if (completedList && completedList.children.length > 0) {
                                // Remove completed tasks from app's tasks array
                                const today = app.currentDate.toISOString().split('T')[0];
                                app.tasks = app.tasks.filter(task => 
                                    !(task.date === today && task.completed)
                                );
                                app.saveTasks();
                                app.renderTasks();
                                app.updateMetrics();
                                showSwipeFeedback('Completed tasks cleared!', 'success');
                            } else {
                                showSwipeFeedback('No completed tasks to clear', 'info');
                            }
                        }
                        break;
                    case 'sync-data':
                        if (app && typeof app.syncToSheetsWithRetry === 'function') {
                            // Show mobile sync feedback
                            showMobileSyncFeedback('Syncing with Google Sheets...', 'info');
                            app.syncToSheetsWithRetry().then(() => {
                                showMobileSyncFeedback('‚úÖ Synced successfully!', 'success');
                            }).catch(() => {
                                showMobileSyncFeedback('‚ùå Sync failed. Check connection.', 'error');
                            });
                        } else if (app && typeof app.syncToSheet === 'function') {
                            app.syncToSheet();
                        }
                        break;
                    case 'voice-add':
                        const voiceBtn = document.getElementById('voice-button');
                        if (voiceBtn) voiceBtn.click();
                        break;
                    case 'export-day':
                        if (app && typeof app.exportDayData === 'function') {
                            app.exportDayData();
                        }
                        break;
                    case 'focus-mode':
                        toggleFocusMode();
                        break;
                    case 'quick-break':
                        startQuickBreak();
                        break;
                    case 'priority-sort':
                        sortTasksByPriority();
                        break;
                    case 'deadline-reminder':
                        setDeadlineReminder();
                        break;
                }
            }

            // Context-Aware Quick Actions System
            function initializeContextAwareActions() {
                const quickActionsContainer = document.querySelector('.quick-actions');
                let userContext = {
                    tasksCompleted: 0,
                    tasksRemaining: 0,
                    timeOfDay: new Date().getHours(),
                    lastActionTime: Date.now(),
                    focusMode: false,
                    streakDays: parseInt(localStorage.getItem('streakDays') || '0'),
                    productivity: 'normal' // low, normal, high
                };

                function updateUserContext() {
                    const pendingTasks = document.querySelectorAll('#pending-tasks li').length;
                    const completedTasks = document.querySelectorAll('#completed-tasks li').length;
                    
                    userContext.tasksCompleted = completedTasks;
                    userContext.tasksRemaining = pendingTasks;
                    userContext.timeOfDay = new Date().getHours();
                    
                    // Calculate productivity level
                    if (completedTasks === 0 && pendingTasks > 3) {
                        userContext.productivity = 'low';
                    } else if (completedTasks > 5 && pendingTasks < 2) {
                        userContext.productivity = 'high';
                    } else {
                        userContext.productivity = 'normal';
                    }
                }

                function generateContextualActions() {
                    updateUserContext();
                    const actions = [];

                    // Morning actions (6-12)
                    if (userContext.timeOfDay >= 6 && userContext.timeOfDay < 12) {
                        actions.push({
                            id: 'morning-planning',
                            icon: 'üåÖ',
                            text: 'Plan Day',
                            action: 'morning-planning',
                            priority: userContext.tasksRemaining === 0 ? 'high' : 'medium'
                        });
                    }

                    // Afternoon actions (12-17)
                    if (userContext.timeOfDay >= 12 && userContext.timeOfDay < 17) {
                        if (userContext.productivity === 'low') {
                            actions.push({
                                id: 'focus-boost',
                                icon: 'üéØ',
                                text: 'Focus Mode',
                                action: 'focus-mode',
                                priority: 'high'
                            });
                        }
                        
                        actions.push({
                            id: 'progress-check',
                            icon: 'üìä',
                            text: 'Check Progress',
                            action: 'progress-check',
                            priority: 'medium'
                        });
                    }

                    // Evening actions (17-23)
                    if (userContext.timeOfDay >= 17 && userContext.timeOfDay < 23) {
                        actions.push({
                            id: 'day-review',
                            icon: 'üîÑ',
                            text: 'Review Day',
                            action: 'day-review',
                            priority: 'medium'
                        });
                        
                        if (userContext.tasksCompleted > 0) {
                            actions.push({
                                id: 'celebrate',
                                icon: 'üéâ',
                                text: 'Celebrate',
                                action: 'celebrate',
                                priority: 'high'
                            });
                        }
                    }

                    // Context-based actions
                    if (userContext.tasksCompleted > 3) {
                        actions.push({
                            id: 'clear-completed',
                            icon: 'üóëÔ∏è',
                            text: 'Clear Done',
                            action: 'clear-completed',
                            priority: 'medium'
                        });
                    }

                    if (userContext.tasksRemaining > 5) {
                        actions.push({
                            id: 'priority-sort',
                            icon: '‚ö°',
                            text: 'Sort by Priority',
                            action: 'priority-sort',
                            priority: 'high'
                        });
                    }

                    if (userContext.productivity === 'low') {
                        actions.push({
                            id: 'quick-break',
                            icon: '‚òï',
                            text: 'Quick Break',
                            action: 'quick-break',
                            priority: 'high'
                        });
                    }

                    // Always available actions
                    actions.push({
                        id: 'sync-data',
                        icon: 'üîÑ',
                        text: 'Sync Sheet',
                        action: 'sync-data',
                        priority: 'low'
                    });

                    actions.push({
                        id: 'voice-add',
                        icon: 'üé§',
                        text: 'Voice Add',
                        action: 'voice-add',
                        priority: 'medium'
                    });

                    return actions.sort((a, b) => {
                        const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                        return priorityOrder[b.priority] - priorityOrder[a.priority];
                    }).slice(0, 4); // Show top 4 actions
                }

                function renderContextualActions() {
                    const actions = generateContextualActions();
                    if (!quickActionsContainer) return;

                    quickActionsContainer.innerHTML = '';
                    actions.forEach(actionData => {
                        const button = document.createElement('button');
                        button.className = `action-btn priority-${actionData.priority}`;
                        button.dataset.action = actionData.action;
                        button.innerHTML = `
                            <span class="action-icon">${actionData.icon}</span>
                            <span class="action-text">${actionData.text}</span>
                        `;
                        quickActionsContainer.appendChild(button);

                        // Add event listener
                        button.addEventListener('click', function() {
                            handleQuickAction(this.dataset.action);
                        });
                    });
                }

                // Smart action implementations
                window.toggleFocusMode = function() {
                    userContext.focusMode = !userContext.focusMode;
                    document.body.classList.toggle('focus-mode', userContext.focusMode);
                    
                    const message = userContext.focusMode ? 
                        'Focus mode activated! Distractions minimized.' : 
                        'Focus mode disabled. Welcome back!';
                    showSwipeFeedback(message, 'info');
                    
                    if (userContext.focusMode) {
                        // Hide completed tasks, minimize UI
                        const completedCard = document.querySelector('.completed-card');
                        if (completedCard) completedCard.style.display = 'none';
                    } else {
                        const completedCard = document.querySelector('.completed-card');
                        if (completedCard) completedCard.style.display = 'block';
                    }
                };

                window.startQuickBreak = function() {
                    showBreakModal();
                };

                window.sortTasksByPriority = function() {
                    // Simple priority sort based on task text patterns
                    const pendingList = document.getElementById('pending-tasks');
                    const tasks = Array.from(pendingList.children);
                    
                    tasks.sort((a, b) => {
                        const aText = a.textContent.toLowerCase();
                        const bText = b.textContent.toLowerCase();
                        
                        // Priority keywords
                        const highPriority = ['urgent', 'asap', 'important', 'deadline'];
                        const aIsHigh = highPriority.some(keyword => aText.includes(keyword));
                        const bIsHigh = highPriority.some(keyword => bText.includes(keyword));
                        
                        if (aIsHigh && !bIsHigh) return -1;
                        if (!aIsHigh && bIsHigh) return 1;
                        return 0;
                    });
                    
                    tasks.forEach(task => pendingList.appendChild(task));
                    showSwipeFeedback('Tasks sorted by priority!', 'success');
                };

                function showBreakModal() {
                    const modal = document.createElement('div');
                    modal.className = 'break-modal';
                    modal.innerHTML = `
                        <div class="break-content">
                            <h3>Quick Break Time! ‚òï</h3>
                            <p>Take a 5-minute break to recharge</p>
                            <div class="break-timer">5:00</div>
                            <div class="break-buttons">
                                <button onclick="this.closest('.break-modal').remove()">Skip</button>
                                <button onclick="startBreakTimer(this.closest('.break-modal'))">Start Break</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);
                }

                window.startBreakTimer = function(modal) {
                    let timeLeft = 300; // 5 minutes
                    const timerDisplay = modal.querySelector('.break-timer');
                    const buttons = modal.querySelector('.break-buttons');
                    
                    buttons.innerHTML = '<button onclick="this.closest(\'.break-modal\').remove()">End Break</button>';
                    
                    const timer = setInterval(() => {
                        timeLeft--;
                        const minutes = Math.floor(timeLeft / 60);
                        const seconds = timeLeft % 60;
                        timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        
                        if (timeLeft <= 0) {
                            clearInterval(timer);
                            modal.remove();
                            showSwipeFeedback('Break time over! Ready to focus?', 'success');
                        }
                    }, 1000);
                };

                // Update actions every 30 seconds
                setInterval(renderContextualActions, 30000);
                
                // Initial render
                setTimeout(renderContextualActions, 1000);
                
                // Re-render on task changes
                const observer = new MutationObserver(() => {
                    setTimeout(renderContextualActions, 500);
                });
                
                ['#pending-tasks', '#completed-tasks'].forEach(selector => {
                    const element = document.querySelector(selector);
                    if (element) {
                        observer.observe(element, { childList: true });
                    }
                });
            }

            // Initialize context-aware actions
            initializeContextAwareActions();

            // Visual Progress Indicators System
            function initializeVisualProgressIndicators() {
                let progressAnimationFrameId = null;
                let streakCount = parseInt(localStorage.getItem('dailyStreak') || '0');
                let todayCompleted = 0;
                let todayTotal = 0;

                // Create floating progress ring
                function createProgressRing() {
                    const ring = document.createElement('div');
                    ring.className = 'progress-ring';
                    ring.innerHTML = `
                        <svg class="progress-circle" width="60" height="60">
                            <circle class="progress-bg" cx="30" cy="30" r="25" fill="none" stroke="#e9ecef" stroke-width="4"/>
                            <circle class="progress-fill" cx="30" cy="30" r="25" fill="none" stroke="#28a745" stroke-width="4" stroke-linecap="round" transform="rotate(-90 30 30)"/>
                        </svg>
                        <div class="progress-text">
                            <span class="progress-percent">0%</span>
                        </div>
                    `;
                    ring.style.cssText = `
                        position: fixed;
                        top: 70px;
                        right: 20px;
                        z-index: 999;
                        opacity: 0;
                        transition: all 0.3s ease;
                        cursor: pointer;
                    `;
                    document.body.appendChild(ring);
                    return ring;
                }

                // Create streak indicator
                function createStreakIndicator() {
                    const streak = document.createElement('div');
                    streak.className = 'streak-indicator';
                    streak.innerHTML = `
                        <div class="streak-flame">üî•</div>
                        <div class="streak-count">${streakCount}</div>
                        <div class="streak-label">day streak</div>
                    `;
                    streak.style.cssText = `
                        position: fixed;
                        top: 140px;
                        right: 20px;
                        z-index: 999;
                        background: linear-gradient(135deg, #ff6b6b, #ffa726);
                        color: white;
                        padding: 12px;
                        border-radius: 15px;
                        text-align: center;
                        font-size: 12px;
                        font-weight: bold;
                        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
                        opacity: ${streakCount > 0 ? '1' : '0'};
                        transform: ${streakCount > 0 ? 'scale(1)' : 'scale(0)'};
                        transition: all 0.3s ease;
                        cursor: pointer;
                    `;
                    document.body.appendChild(streak);
                    return streak;
                }

                // Create celebration particles
                function createCelebrationParticles(x, y) {
                    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b'];
                    const particles = [];

                    for (let i = 0; i < 15; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'celebration-particle';
                        particle.style.cssText = `
                            position: fixed;
                            left: ${x}px;
                            top: ${y}px;
                            width: 6px;
                            height: 6px;
                            background: ${colors[Math.floor(Math.random() * colors.length)]};
                            border-radius: 50%;
                            pointer-events: none;
                            z-index: 10000;
                        `;
                        document.body.appendChild(particle);
                        particles.push(particle);

                        // Animate particle
                        const angle = (Math.PI * 2 * i) / 15;
                        const velocity = 50 + Math.random() * 50;
                        const vx = Math.cos(angle) * velocity;
                        const vy = Math.sin(angle) * velocity;

                        let px = x;
                        let py = y;
                        let vy_current = vy;
                        const gravity = 2;
                        const friction = 0.98;

                        const animateParticle = () => {
                            px += vx * friction;
                            py += vy_current;
                            vy_current += gravity;

                            particle.style.left = px + 'px';
                            particle.style.top = py + 'px';
                            particle.style.opacity = Math.max(0, parseFloat(particle.style.opacity || 1) - 0.02);

                            if (parseFloat(particle.style.opacity || 1) > 0 && py < window.innerHeight + 20) {
                                requestAnimationFrame(animateParticle);
                            } else {
                                particle.remove();
                            }
                        };

                        requestAnimationFrame(animateParticle);
                    }

                    setTimeout(() => {
                        particles.forEach(p => p.remove());
                    }, 3000);
                }

                // Create milestone celebration
                function createMilestoneCelebration(message, type = 'achievement') {
                    const celebration = document.createElement('div');
                    celebration.className = `milestone-celebration ${type}`;
                    celebration.innerHTML = `
                        <div class="milestone-content">
                            <div class="milestone-icon">${type === 'achievement' ? 'üèÜ' : type === 'streak' ? 'üî•' : '‚≠ê'}</div>
                            <div class="milestone-message">${message}</div>
                        </div>
                    `;
                    celebration.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%) scale(0);
                        z-index: 10002;
                        background: linear-gradient(135deg, #667eea, #764ba2);
                        color: white;
                        padding: 30px;
                        border-radius: 20px;
                        text-align: center;
                        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
                        animation: milestoneAppear 3s ease forwards;
                    `;
                    document.body.appendChild(celebration);

                    // Auto remove after animation
                    setTimeout(() => {
                        celebration.remove();
                    }, 3000);

                    return celebration;
                }

                // Update progress indicators
                function updateProgressIndicators() {
                    const pendingTasks = document.querySelectorAll('#pending-tasks li').length;
                    const completedTasks = document.querySelectorAll('#completed-tasks li').length;
                    todayTotal = pendingTasks + completedTasks;
                    todayCompleted = completedTasks;

                    const progressPercent = todayTotal > 0 ? Math.round((todayCompleted / todayTotal) * 100) : 0;

                    // Update progress ring
                    const progressRing = document.querySelector('.progress-ring');
                    if (progressRing) {
                        const progressCircle = progressRing.querySelector('.progress-fill');
                        const progressText = progressRing.querySelector('.progress-percent');
                        
                        if (progressCircle && progressText) {
                            const circumference = 2 * Math.PI * 25; // radius = 25
                            const strokeDasharray = circumference;
                            const strokeDashoffset = circumference - (progressPercent / 100) * circumference;
                            
                            progressCircle.style.strokeDasharray = strokeDasharray;
                            progressCircle.style.strokeDashoffset = strokeDashoffset;
                            progressCircle.style.transition = 'stroke-dashoffset 0.5s ease';
                            
                            progressText.textContent = progressPercent + '%';
                        }

                        // Show/hide ring based on activity
                        progressRing.style.opacity = todayTotal > 0 ? '1' : '0';
                        progressRing.style.transform = todayTotal > 0 ? 'scale(1)' : 'scale(0.8)';
                    }

                    // Update task counters with animations
                    const pendingCount = document.getElementById('pending-count');
                    const completedCount = document.getElementById('completed-count');
                    
                    if (pendingCount) {
                        pendingCount.textContent = `${pendingTasks} pending`;
                        if (pendingTasks === 0 && todayTotal > 0) {
                            pendingCount.style.color = '#28a745';
                            pendingCount.style.fontWeight = 'bold';
                        } else {
                            pendingCount.style.color = '';
                            pendingCount.style.fontWeight = '';
                        }
                    }
                    
                    if (completedCount) {
                        completedCount.textContent = `${completedTasks} done`;
                        if (completedTasks > 0) {
                            completedCount.style.color = '#28a745';
                            completedCount.style.fontWeight = '600';
                        }
                    }

                    // Update progress card stats
                    const totalTasksElement = document.getElementById('total-tasks');
                    const completionPercentElement = document.getElementById('completion-percentage');
                    const completionPercentTextElement = document.getElementById('completion-percentage-text');
                    const completionBarElement = document.getElementById('completion-bar');

                    if (totalTasksElement) totalTasksElement.textContent = todayTotal;
                    if (completionPercentElement) completionPercentElement.textContent = progressPercent;
                    if (completionPercentTextElement) completionPercentTextElement.textContent = progressPercent + '%';
                    if (completionBarElement) completionBarElement.style.width = progressPercent + '%';

                    // Check for milestones
                    checkMilestones(progressPercent, completedTasks);
                }

                // Check for achievement milestones
                function checkMilestones(progressPercent, completedTasks) {
                    const lastProgress = parseInt(sessionStorage.getItem('lastProgress') || '0');
                    const lastCompleted = parseInt(sessionStorage.getItem('lastCompleted') || '0');

                    // Day completion milestone
                    if (progressPercent === 100 && lastProgress < 100) {
                        createMilestoneCelebration('Perfect Day Complete! üéâ', 'achievement');
                        incrementStreak();
                        
                        // Trigger celebration particles
                        const progressRing = document.querySelector('.progress-ring');
                        if (progressRing) {
                            const rect = progressRing.getBoundingClientRect();
                            createCelebrationParticles(rect.left + rect.width/2, rect.top + rect.height/2);
                        }
                    }

                    // Task completion milestones
                    if (completedTasks > lastCompleted) {
                        if (completedTasks === 5) {
                            createMilestoneCelebration('5 Tasks Done! On a roll! üöÄ', 'streak');
                        } else if (completedTasks === 10) {
                            createMilestoneCelebration('10 Tasks Complete! Productivity Master! üí™', 'achievement');
                        }
                    }

                    // Save current state
                    sessionStorage.setItem('lastProgress', progressPercent.toString());
                    sessionStorage.setItem('lastCompleted', completedTasks.toString());
                }

                // Increment daily streak
                function incrementStreak() {
                    const today = new Date().toDateString();
                    const lastStreakDate = localStorage.getItem('lastStreakDate');
                    
                    if (lastStreakDate !== today) {
                        streakCount++;
                        localStorage.setItem('dailyStreak', streakCount.toString());
                        localStorage.setItem('lastStreakDate', today);
                        
                        // Update streak indicator
                        const streakIndicator = document.querySelector('.streak-indicator');
                        if (streakIndicator) {
                            const streakCountElement = streakIndicator.querySelector('.streak-count');
                            if (streakCountElement) {
                                streakCountElement.textContent = streakCount;
                            }
                            streakIndicator.style.opacity = '1';
                            streakIndicator.style.transform = 'scale(1.1)';
                            setTimeout(() => {
                                streakIndicator.style.transform = 'scale(1)';
                            }, 300);
                        }
                    }
                }

                // Initialize all indicators
                const progressRing = createProgressRing();
                const streakIndicator = createStreakIndicator();

                // Click handlers for indicators
                progressRing.addEventListener('click', () => {
                    // Navigate to progress card
                    const progressCard = document.querySelector('.progress-card');
                    if (progressCard) {
                        currentCard = 3; // Progress card index
                        updateCardPosition();
                        updateDots();
                    }
                });

                streakIndicator.addEventListener('click', () => {
                    showStreakHistory();
                });

                // Set up observers
                const observer = new MutationObserver(() => {
                    clearTimeout(progressAnimationFrameId);
                    progressAnimationFrameId = setTimeout(updateProgressIndicators, 300);
                });
                
                ['#pending-tasks', '#completed-tasks'].forEach(selector => {
                    const element = document.querySelector(selector);
                    if (element) {
                        observer.observe(element, { childList: true, subtree: true });
                    }
                });

                // Initial update
                setTimeout(updateProgressIndicators, 1000);

                function showStreakHistory() {
                    const modal = document.createElement('div');
                    modal.className = 'streak-history-modal';
                    modal.innerHTML = `
                        <div class="streak-history-content">
                            <h3>üî• Daily Streak</h3>
                            <div class="current-streak">${streakCount} consecutive days</div>
                            <p>Keep completing tasks daily to maintain your streak!</p>
                            <button onclick="this.closest('.streak-history-modal').remove()">Close</button>
                        </div>
                    `;
                    modal.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10003;
                    `;
                    document.body.appendChild(modal);
                }
            }

            // Initialize visual progress indicators
            if (window.innerWidth <= 768) {
                initializeVisualProgressIndicators();
            }

            // Mobile Sync Feedback System
            function showMobileSyncFeedback(message, type = 'info') {
                // Remove any existing sync feedback
                const existing = document.querySelector('.mobile-sync-feedback');
                if (existing) existing.remove();

                const feedback = document.createElement('div');
                feedback.className = `mobile-sync-feedback ${type}`;
                feedback.innerHTML = `
                    <div class="sync-feedback-content">
                        <div class="sync-feedback-icon">
                            ${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : 'üîÑ'}
                        </div>
                        <div class="sync-feedback-message">${message}</div>
                        ${type === 'info' ? '<div class="sync-feedback-loader"></div>' : ''}
                    </div>
                `;
                feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    z-index: 10001;
                    background: ${type === 'success' ? '#28a745' : type === 'error' ? '#dc3545' : '#17a2b8'};
                    color: white;
                    padding: 15px 20px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: 500;
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                    animation: syncFeedbackSlide 0.3s ease forwards;
                    max-width: 90%;
                    text-align: center;
                `;
                
                document.body.appendChild(feedback);

                // Auto remove success/error messages
                if (type !== 'info') {
                    setTimeout(() => {
                        feedback.style.animation = 'syncFeedbackSlideOut 0.3s ease forwards';
                        setTimeout(() => feedback.remove(), 300);
                    }, 3000);
                }

                return feedback;
            }

            // Make function globally available
            window.showMobileSyncFeedback = showMobileSyncFeedback;

            // Google Sheets Integration Testing
            function testGoogleSheetsIntegration() {
                if (window.innerWidth > 768) return; // Desktop only shows regular messages

                // Test mobile-specific sync indicators
                const syncActions = document.querySelectorAll('[data-action="sync-data"]');
                syncActions.forEach(button => {
                    button.addEventListener('click', () => {
                        // Add loading state to sync buttons
                        button.style.opacity = '0.6';
                        button.style.pointerEvents = 'none';
                        
                        setTimeout(() => {
                            button.style.opacity = '1';
                            button.style.pointerEvents = 'auto';
                        }, 2000);
                    });
                });

                // Monitor app sync status and provide mobile feedback
                if (app) {
                    // Override showMessage for mobile sync messages
                    const originalShowMessage = app.showMessage;
                    app.showMessage = function(message, type) {
                        if (window.innerWidth <= 768 && (
                            message.includes('sync') || 
                            message.includes('Sync') || 
                            message.includes('Sheet') || 
                            message.includes('Connected')
                        )) {
                            showMobileSyncFeedback(message, type);
                        } else {
                            originalShowMessage.call(this, message, type);
                        }
                    };

                    // Add mobile-specific sync status indicator
                    const createMobileSyncStatus = () => {
                        let syncStatus = document.querySelector('.mobile-sync-status');
                        if (!syncStatus) {
                            syncStatus = document.createElement('div');
                            syncStatus.className = 'mobile-sync-status';
                            syncStatus.innerHTML = '‚ö°';
                            syncStatus.style.cssText = `
                                position: fixed;
                                bottom: 90px;
                                right: 20px;
                                z-index: 999;
                                width: 40px;
                                height: 40px;
                                background: #28a745;
                                color: white;
                                border-radius: 50%;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 16px;
                                box-shadow: 0 2px 10px rgba(40, 167, 69, 0.3);
                                opacity: 0;
                                transform: scale(0);
                                transition: all 0.3s ease;
                                cursor: pointer;
                            `;
                            document.body.appendChild(syncStatus);

                            syncStatus.addEventListener('click', () => {
                                const syncAction = document.querySelector('[data-action="sync-data"]');
                                if (syncAction) syncAction.click();
                            });
                        }
                        return syncStatus;
                    };

                    const mobileSyncStatus = createMobileSyncStatus();

                    // Show/hide sync status based on authentication
                    if (app.isAuthenticated && app.sheetId) {
                        mobileSyncStatus.style.opacity = '1';
                        mobileSyncStatus.style.transform = 'scale(1)';
                        mobileSyncStatus.title = 'Google Sheets connected - Tap to sync';
                    } else {
                        mobileSyncStatus.style.opacity = '0.3';
                        mobileSyncStatus.style.transform = 'scale(0.8)';
                        mobileSyncStatus.innerHTML = '‚ö†Ô∏è';
                        mobileSyncStatus.title = 'Google Sheets not connected';
                    }
                }
            }

            // Initialize Google Sheets integration testing
            setTimeout(testGoogleSheetsIntegration, 2000);
            
            // Final mobile functionality testing and debugging
            function runMobileFunctionalityTest() {
                console.log('üîß Running mobile functionality test...');
                
                // Test 1: Check if app is properly initialized
                if (!app) {
                    console.error('‚ùå App not initialized');
                    return;
                }
                
                // Test 2: Check if required elements exist
                const requiredElements = ['task-input', 'add-task-btn', 'pending-tasks', 'completed-tasks'];
                const missingElements = [];
                
                requiredElements.forEach(id => {
                    if (!document.getElementById(id)) {
                        missingElements.push(id);
                    }
                });
                
                if (missingElements.length > 0) {
                    console.error('‚ùå Missing required elements:', missingElements);
                } else {
                    console.log('‚úÖ All required elements found');
                }
                
                // Test 3: Check if mobile layout is properly configured
                if (window.innerWidth <= 768) {
                    const mobileContainer = document.querySelector('.mobile-cards-container');
                    const desktopLayout = document.querySelector('.desktop-layout');
                    
                    if (mobileContainer && getComputedStyle(mobileContainer).display !== 'none') {
                        console.log('‚úÖ Mobile layout active');
                    } else {
                        console.warn('‚ö†Ô∏è Mobile layout not active');
                    }
                    
                    if (desktopLayout && getComputedStyle(desktopLayout).display === 'none') {
                        console.log('‚úÖ Desktop layout hidden on mobile');
                    } else {
                        console.warn('‚ö†Ô∏è Desktop layout not hidden on mobile');
                    }
                }
                
                // Test 4: Check if event listeners are attached
                const taskInput = document.getElementById('task-input');
                const addBtn = document.getElementById('add-task-btn');
                
                if (taskInput && taskInput.onclick !== null || taskInput.onkeypress !== null) {
                    console.log('‚úÖ Task input has event listeners');
                } else {
                    console.warn('‚ö†Ô∏è Task input may be missing event listeners');
                }
                
                if (addBtn && (addBtn.onclick !== null || addBtn.addEventListener)) {
                    console.log('‚úÖ Add button has event listeners');
                } else {
                    console.warn('‚ö†Ô∏è Add button may be missing event listeners');
                }
                
                // Test 5: Force render tasks to ensure display
                if (app && typeof app.renderTasks === 'function') {
                    try {
                        app.renderTasks();
                        console.log('‚úÖ Tasks rendered successfully');
                    } catch (error) {
                        console.error('‚ùå Error rendering tasks:', error);
                    }
                }
                
                // Test 6: Check if swipe gestures are initialized
                const taskItems = document.querySelectorAll('.task-list li');
                if (taskItems.length > 0 && window.innerWidth <= 768) {
                    console.log(`‚úÖ Found ${taskItems.length} task items for swipe gestures`);
                } else if (window.innerWidth <= 768) {
                    console.log('‚ÑπÔ∏è No tasks found - swipe gestures will activate when tasks are added');
                }
                
                // Test 7: Verify navigation works
                const dockItems = document.querySelectorAll('.dock-item[data-view]');
                const views = document.querySelectorAll('.view');
                
                if (dockItems.length > 0 && views.length > 0) {
                    console.log('‚úÖ Navigation elements found');
                } else {
                    console.error('‚ùå Navigation elements missing');
                }
                
                console.log('üéâ Mobile functionality test completed!');
                
                // Show success message to user
                if (window.innerWidth <= 768) {
                    setTimeout(() => {
                        showSwipeFeedback('Mobile UI loaded successfully! üöÄ', 'success');
                    }, 1000);
                }
            }
            
            // Run test after everything is loaded
            setTimeout(runMobileFunctionalityTest, 3000);

            // Task Swipe Gesture Controls
            function initializeTaskSwipeGestures() {
                let taskStartX = 0;
                let taskCurrentX = 0;
                let taskIsDragging = false;
                let currentTaskElement = null;

                // Delegate event listeners for dynamic task elements
                document.addEventListener('touchstart', handleTaskTouchStart, { passive: true });
                document.addEventListener('touchmove', handleTaskTouchMove, { passive: false });
                document.addEventListener('touchend', handleTaskTouchEnd, { passive: true });
                
                // Mouse events for testing
                document.addEventListener('mousedown', handleTaskMouseDown);
                document.addEventListener('mousemove', handleTaskMouseMove);
                document.addEventListener('mouseup', handleTaskMouseUp);

                function isTaskElement(element) {
                    return element.classList.contains('task-item') || 
                           element.closest('.task-item') || 
                           element.tagName === 'LI' && (element.closest('#pending-tasks') || element.closest('#completed-tasks'));
                }

                function getTaskElement(element) {
                    if (element.classList.contains('task-item') || element.tagName === 'LI') {
                        return element;
                    }
                    return element.closest('.task-item') || element.closest('li');
                }

                function handleTaskTouchStart(e) {
                    const target = e.target;
                    const taskElement = getTaskElement(target);
                    
                    if (taskElement && window.innerWidth <= 768) {
                        taskStartX = e.touches[0].clientX;
                        taskIsDragging = false;
                        currentTaskElement = taskElement;
                        
                        // Add swipe indicators
                        taskElement.style.position = 'relative';
                        createSwipeIndicators(taskElement);
                    }
                }

                function handleTaskTouchMove(e) {
                    if (!currentTaskElement) return;
                    
                    taskCurrentX = e.touches[0].clientX;
                    const diffX = taskCurrentX - taskStartX;
                    
                    if (Math.abs(diffX) > 10) {
                        taskIsDragging = true;
                        e.preventDefault();
                        
                        const maxSwipe = 100;
                        const constrainedDiffX = Math.max(-maxSwipe, Math.min(maxSwipe, diffX));
                        
                        currentTaskElement.style.transform = `translateX(${constrainedDiffX}px)`;
                        currentTaskElement.style.transition = 'none';
                        
                        updateSwipeIndicators(currentTaskElement, constrainedDiffX);
                    }
                }

                function handleTaskTouchEnd(e) {
                    if (!currentTaskElement || !taskIsDragging) {
                        if (currentTaskElement) {
                            removeSwipeIndicators(currentTaskElement);
                            currentTaskElement = null;
                        }
                        return;
                    }
                    
                    const diffX = taskCurrentX - taskStartX;
                    const threshold = 60;
                    
                    currentTaskElement.style.transition = 'transform 0.3s ease';
                    
                    if (Math.abs(diffX) > threshold) {
                        if (diffX > 0) {
                            // Swipe right - Mark as complete/incomplete
                            handleSwipeComplete(currentTaskElement);
                        } else {
                            // Swipe left - Delete
                            handleSwipeDelete(currentTaskElement);
                        }
                    } else {
                        // Snap back
                        currentTaskElement.style.transform = 'translateX(0)';
                    }
                    
                    setTimeout(() => {
                        if (currentTaskElement) {
                            removeSwipeIndicators(currentTaskElement);
                            currentTaskElement.style.transition = '';
                            currentTaskElement = null;
                        }
                    }, 300);
                    
                    taskIsDragging = false;
                }

                function handleTaskMouseDown(e) {
                    const target = e.target;
                    const taskElement = getTaskElement(target);
                    
                    if (taskElement && window.innerWidth <= 768) {
                        taskStartX = e.clientX;
                        taskIsDragging = false;
                        currentTaskElement = taskElement;
                        createSwipeIndicators(taskElement);
                        e.preventDefault();
                    }
                }

                function handleTaskMouseMove(e) {
                    if (!currentTaskElement) return;
                    
                    taskCurrentX = e.clientX;
                    const diffX = taskCurrentX - taskStartX;
                    
                    if (Math.abs(diffX) > 10) {
                        taskIsDragging = true;
                        
                        const maxSwipe = 100;
                        const constrainedDiffX = Math.max(-maxSwipe, Math.min(maxSwipe, diffX));
                        
                        currentTaskElement.style.transform = `translateX(${constrainedDiffX}px)`;
                        currentTaskElement.style.transition = 'none';
                        
                        updateSwipeIndicators(currentTaskElement, constrainedDiffX);
                    }
                }

                function handleTaskMouseUp(e) {
                    if (!currentTaskElement || !taskIsDragging) {
                        if (currentTaskElement) {
                            removeSwipeIndicators(currentTaskElement);
                            currentTaskElement = null;
                        }
                        return;
                    }
                    
                    const diffX = taskCurrentX - taskStartX;
                    const threshold = 60;
                    
                    currentTaskElement.style.transition = 'transform 0.3s ease';
                    
                    if (Math.abs(diffX) > threshold) {
                        if (diffX > 0) {
                            handleSwipeComplete(currentTaskElement);
                        } else {
                            handleSwipeDelete(currentTaskElement);
                        }
                    } else {
                        currentTaskElement.style.transform = 'translateX(0)';
                    }
                    
                    setTimeout(() => {
                        if (currentTaskElement) {
                            removeSwipeIndicators(currentTaskElement);
                            currentTaskElement.style.transition = '';
                            currentTaskElement = null;
                        }
                    }, 300);
                    
                    taskIsDragging = false;
                }

                function createSwipeIndicators(taskElement) {
                    const leftIndicator = document.createElement('div');
                    leftIndicator.className = 'swipe-indicator swipe-delete';
                    leftIndicator.innerHTML = '<span>üóëÔ∏è</span><span>Delete</span>';
                    
                    const rightIndicator = document.createElement('div');
                    rightIndicator.className = 'swipe-indicator swipe-complete';
                    const isCompleted = taskElement.closest('#completed-tasks');
                    rightIndicator.innerHTML = isCompleted ? '<span>‚Ü©Ô∏è</span><span>Undo</span>' : '<span>‚úÖ</span><span>Done</span>';
                    
                    taskElement.appendChild(leftIndicator);
                    taskElement.appendChild(rightIndicator);
                }

                function updateSwipeIndicators(taskElement, diffX) {
                    const leftIndicator = taskElement.querySelector('.swipe-delete');
                    const rightIndicator = taskElement.querySelector('.swipe-complete');
                    
                    const opacity = Math.abs(diffX) / 60;
                    
                    if (diffX > 0) {
                        rightIndicator.style.opacity = Math.min(1, opacity);
                        leftIndicator.style.opacity = 0;
                    } else {
                        leftIndicator.style.opacity = Math.min(1, opacity);
                        rightIndicator.style.opacity = 0;
                    }
                }

                function removeSwipeIndicators(taskElement) {
                    const indicators = taskElement.querySelectorAll('.swipe-indicator');
                    indicators.forEach(indicator => indicator.remove());
                }

                function handleSwipeComplete(taskElement) {
                    // Trigger task completion/incompletion
                    const checkbox = taskElement.querySelector('input[type="checkbox"]');
                    if (checkbox) {
                        // Toggle checkbox and trigger app's event handler
                        checkbox.checked = !checkbox.checked;
                        
                        // Find the task in app's tasks array and update it
                        const taskText = taskElement.querySelector('.task-content')?.textContent || 
                                        taskElement.textContent.trim().replace('√ó', '').trim();
                        const today = app.currentDate.toISOString().split('T')[0];
                        
                        const task = app.tasks.find(t => 
                            t.date === today && 
                            t.text.trim() === taskText.trim()
                        );
                        
                        if (task) {
                            task.completed = checkbox.checked;
                            if (checkbox.checked) {
                                task.completedAt = new Date().toISOString();
                            } else {
                                delete task.completedAt;
                            }
                            
                            app.saveTasks();
                            app.renderTasks();
                            app.updateMetrics();
                        }
                        
                        // Manual event for older browsers
                        const event = new Event('change', { bubbles: true });
                        checkbox.dispatchEvent(event);
                    }
                    
                    taskElement.style.transform = 'translateX(0)';
                    
                    // Show feedback
                    showSwipeFeedback('Task status updated!', 'success');
                }

                function handleSwipeDelete(taskElement) {
                    // Animate deletion
                    taskElement.style.transform = 'translateX(-100%)';
                    taskElement.style.opacity = '0';
                    
                    setTimeout(() => {
                        // Find and remove task from app's tasks array
                        const taskText = taskElement.querySelector('.task-content')?.textContent || 
                                        taskElement.textContent.trim().replace('√ó', '').trim();
                        const today = app.currentDate.toISOString().split('T')[0];
                        
                        const taskIndex = app.tasks.findIndex(t => 
                            t.date === today && 
                            t.text.trim() === taskText.trim()
                        );
                        
                        if (taskIndex !== -1) {
                            app.tasks.splice(taskIndex, 1);
                            app.saveTasks();
                            app.renderTasks();
                            app.updateMetrics();
                        } else {
                            // Fallback: remove from DOM
                            taskElement.remove();
                        }
                        
                        showSwipeFeedback('Task deleted', 'info');
                    }, 300);
                }

                function showSwipeFeedback(message, type = 'info') {
                    const feedback = document.createElement('div');
                    feedback.className = `swipe-feedback ${type}`;
                    feedback.textContent = message;
                    feedback.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: ${type === 'success' ? '#28a745' : type === 'info' ? '#17a2b8' : '#dc3545'};
                        color: white;
                        padding: 12px 20px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 500;
                        z-index: 10000;
                        animation: swipeFeedbackAnimation 2s ease forwards;
                    `;
                    
                    document.body.appendChild(feedback);
                    
                    setTimeout(() => {
                        feedback.remove();
                    }, 2000);
                }
            }

            // Initialize task swipe gestures
            initializeTaskSwipeGestures();
        });
    </script>
</body>
</html>